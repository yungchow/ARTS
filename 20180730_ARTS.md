### Algorithm

***

Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.

**Example 1:**

```
Input: [2,2,1]
Output: 1
```

**Example 2:**

```
Input: [4,1,2,1,2]
Output: 4
```

 **Solution:**

```java
class Solution {
    //时间复杂度O(n+n),空间复杂度O(n+n)
    public int singleNumber(int[] nums) {
        int sum = 0;
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0 ; i < nums.length; i++){
            sum += nums[i];
            set.add(nums[i]);
        }
        
        int singleSum = 0;

		Iterator it = set.iterator();
		while (it.hasNext()) {
			singleSum = singleSum + (Integer)it.next();
		}
        
        return singleSum*2 - sum;
    }
    
    //使用异或位运算，空间复杂度O(1)
    public int singleNumber2(int[] nums) {
        int result = 0;
        for(int i : nums) {
            result ^= i;
        }
        return result; 
    }
}
```



### Review

***

[Scalable Web Architecture and Distributed Systems](http://www.aosabook.org/en/distsys.html)

本周的Article Review有关分布式架构的文章，这篇文章从一个图片存储服务的例子粗略给出了设计分布式架构需要考虑的几个要点以及如何解决分布式架构中可能出现的问题

##### 分布式Web系统设计要点

- 可用性

  对于大型零售网站来说，甚至一分钟的瘫痪都会导致百万的损失，高可用在分布式系统中需要对关键部分的冗余设计做仔细斟酌，以及面对系统宕机等问题的迅速恢复的处理

- 表现力

  表现在系统的响应速度，用户体验满意度，搜索引擎的排序等，总的来说，高速响应和低延迟是关键

- 可靠性

  对请求的数据应该能保证是没有被污染的，能够及时更新的

- 伸缩性

  系统的可扩展性

- 可管理性

  考虑到一个系统的易操作性同样重要，易于诊断和理解问题发生的原因以及相应的修改或者更新的操作

- 成本

  软硬件的开销，开发的工作量，对运行系统的维护，涉及到的培训等

  以上在开发分布式系统中需要考虑的要点可能互相冲突，需要根据实际情况做出取舍

#### 从一个简单的图片服务系统开始

**服务分离**

考虑到系统的伸缩性设计时，对功能解耦并分别提供定义清晰的服务接口常常提供很好的帮助，即Service-Oriented-Architecture.将一个复杂系统分成一个个完整的服务使得这些服务之间的关系变得明确，问题得以分离，同样使得自身的伸缩独立于其它的部分，跟OOP十分类似，在我们的图片系统中明显需要把上传和下载分离成单独的服务，在服务器运行繁忙的场景中，图片的写操作会严重影响读取的速度

另一个潜在的问题是例如Apache或者lighttpd通常有一个可维护的同时连接数目的上限（默认500），在访问高峰时期，写操作会占用大量的连接时间，上传文件的过程中始终保持一个连接，所以上传1M文件按照通常的网络速度需要超过1秒，那么服务器在同一时间只能处理500个写请求

服务上的读写分离可以实现各自扩展，也易于排查问题

**冗余设计**

为应对重大问题，冗余设计必不可少

保证多服务器同时运行能够应对单个节点宕机的问题

服务器冗余的关键是创造一个shard-nothing-architecture,这种设计下每个节点可以独立于其它节点，这里没有中心节点维护其它节点的状态，这种实现对系统的伸缩性有极大的提高，一个新节点的加入不需要特殊的条件

**扩展**

当数据集大到一定程度的时候，或者一个操作需要占用太多的计算资源会降低响应速度，此时需要横向扩展或者纵向扩展

纵向扩展：加内存，升CPU

水平扩展：增加节点数，新增服务器存储更多的数据，或者将计算量大的操作分离到单独的服务器中

分布式数据带来的一些挑战：data locality,inconsistency



#### 快速、可扩展的数据访问

**缓存**

分布式缓存，典型的分布式缓存使用哈希一致性算法切分，当一个请求节点请求数据时可以快速得知在从分布式缓存中的哪里获取并判断数据是否可以得到。在本例中，每个节点有一小块缓存，在向服务请求数据之前会发送给其它节点请求数据

分布式缓存的缺点在于处理丢失节点的问题，有些分布式缓存通过备份多个其它节点的数据来解决，但是这种方式带来了极大的复杂度，尤其是当你增加或者移出节点的时候，虽然节点丢失，依然可以从源头获取数据，所以并不是重大灾难

缓存虽然带来了速度上的提升，但是也要耗费相当的存储空间

Memcached通常使用在大型网站中，非常强大，仅仅通过在内存中使用简单的KV存储，获得O(1)的查询速度

**代理**

通常，代理用来过滤请求，打印请求日志，重定向

通过代理提高访问速度的一个方法是把多个相同或者相似的请求合并成一个请求，返回一个请求结果，即collapsed forwarding,虽然会带来一些客户端响应上的延迟，但是会提高高负载情况下的表现

代理服务器通常也可以缓存，但是缓存就不能扮演代理的角色

另一种通过代理提高访问速度的方式是根据请求数据在数据库中分布位置的特点，将连续排列的数据请求以整个数据的方式返回

通常情况下，会把缓存放在代理之前，因为缓存是在内存中返回的，非常快，并不介意返回多个相同的结果

如果你考虑在系统中增加代理，Squid,Varnish通常都是被广泛使用的

**索引**

索引是广为人知用于提升数据访问速度的技术，最被大众知晓的应该是数据库索引，索引以增加存储和降低写的速度为代价来提高读取的速度

**负载均衡**

负载均衡可以通过硬件或者软件来实现，开源软件负载均衡：HAProxy

负载均衡的一个挑战在于管理用户session数据，在一个电商网站的例子中，如果一个用户两次访问服务到不同的节点上，无法同步数据，（browser cache,cookies,url rewriting）

负载均衡提供了检测节点健康等重要功能，如果一个节点过载或者无响应，可以将其从轮询请求处理中移除



#### 队列

通过队列的方式实现系统在写入操作上提高性能



### Tip

***

项目开发中关于配置文件的tip

- **pom.xml**文件的<profile>标签可以配置开发，测试，线上环境中的数据库,redis服务器的ip等参数，配合**Jenkins**配置实现不同环境的打包部署

  ```xml
  <profiles>
      <!-- 开发环境 -->
  	<profile>
      	<id>dev</id>
          <properties>
          	<dbip></dbip>
              <dbname></dbname>
          </properties>
      </profile>
      <!-- 测试环境 -->
      <profile>
      	<id>test</id>
          ...
      </profile>
  </profiles>
  ```

  **Jenkins**中的配置：

  构建项目configure下的Build属性：

  ​	Root POM:pom.xml

  ​	Goals and options:clean package -DskipTests -Pdev

### Share

***

近期大致看了一遍**clean code**,了解了一些关于如何编写整洁代码的规则要点，自己在code review时也会按照这些经验重构代码，优化代码的过程也是对自己代码审美的提高，整洁且优雅的代码更容易让读者理解，甚至不需要熟悉语法，虽然这些对程序员来说至关重要的技术在面试过程中可能不会涉及，但是真正每天跟代码接触的是我们自己，编写更完美的代码可以让自己在每一次敲击键盘的过程中都能得到满足感，有时候会停下不禁为自己的设计而兴奋，相比于复制粘贴的工作也更加充实吧

